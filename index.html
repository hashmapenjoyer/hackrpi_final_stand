<!DOCTYPE html>
<html>
<head>
    <title>Retro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">
</head>
<body>

    <div id="introContent">
        <h1>header one</h1>
        <button id="triggerWipe">button</button>
    </div>

    <div id="wipeOverlay"></div>

    <div id="sceneContainer">
        <div id="sky"></div>

        <h1 id="sceneTitle">LIFE MAXER</h1>

        <div id="gridContainer">
            <svg id="perspectiveGrid" width="100%" height="100%" preserveAspectRatio="none"></svg>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.3/gsap.min.js"></script>

    <script>
        const introContent = document.getElementById('introContent');
        const triggerWipe = document.getElementById('triggerWipe');
        const wipe = document.getElementById('wipeOverlay');
        const sceneContainer = document.getElementById('sceneContainer');
        const svg = document.getElementById('perspectiveGrid');

        const sceneTitle = document.getElementById('sceneTitle');

        function buildGrid() {
            const width = window.innerWidth;
            const height = window.innerHeight * 0.6; // Use 60% height of viewport (since container is 60%)
            const horizonHeight = 0; // The container's 0 is the horizon

            const vx = width / 2;
            const vy = horizonHeight; 

            const numVertical = 20;
            const numHorizontal = 12;

            const verticalLines = [];
            const horizontalLines = [];

            const overshoot = width * 1.5;
            const leftBound = -overshoot;
            const rightBound = width + overshoot;
            
            for (let i = 0; i <= numVertical; i++) {
                const x = leftBound + ((rightBound - leftBound) / numVertical) * i;

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", x);
                line.setAttribute("y1", height); 
                line.setAttribute("x2", x);
                line.setAttribute("y2", height);
                svg.appendChild(line);

                verticalLines.push({
                    element: line,
                    final: { x2: vx, y2: vy },
                    old: { x1: x, y1: height, x2: x, y2: height}
                });
            }

            for (let j = 0; j < numHorizontal; j++) {
                const t = j / (numHorizontal - 1);
                
                // this is some super bullshit btw
                const perspectiveFactor = 0.8;
                const eased = Math.pow(1 - t, 1 + perspectiveFactor * 2);
                
                const y = horizonHeight + (height - horizonHeight) * eased;

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                const startX = (j % 2 ? 0 : width);
                line.setAttribute("x1", startX);
                line.setAttribute("x2", startX);
                line.setAttribute("y1", y);
                line.setAttribute("y2", y);
                svg.appendChild(line);

                horizontalLines.push({
                    element: line,
                    final: { x1: 0, x2: width },
                    old: { x1: startX, y1: y, x2: startX, y2: y}
                });
            }

            return [verticalLines, horizontalLines];
        }

        function getIntersection(vLine, hLine) {
            const vLine_is_vertical = vLine.old.x1 === vLine.final.x2;
            if (vLine_is_vertical) {
                return { x: vLine.old.x1, y: hLine.old.y1 }
            }

            const vLine_is_horizontal = vLine.old.y1 === vLine.final.y2;
            if (vLine_is_horizontal) {
                //should only be possible if I really mess up generation but whatever
                console.error('vertical grid line is horizontal somehow??')
                return { x: 0, y: 0 }
            }

            const m = (vLine.final.y2 - vLine.old.y1) / (vLine.final.x2 - vLine.old.x1);

            // (intersection_y - y2) = m * (intersection_x - x2)
            // intersection_x = (intersection_y - y2) / m + x2
            const x_intersection = vLine.final.x2 + (hLine.old.y1 - vLine.final.y2) / m

            return { x: x_intersection, y: hLine.old.y1 }
        }
        
        function buildClickableLayer(hLines, vLines) {
            for (let j = 0; j < hLines.length - 1; j++) {
                for (let i = 0; i < vLines.length - 1; i++) {
                    // get the 4 lines that define this tile
                    const vLine1 = vLines[i];
                    const vLine2 = vLines[i+1];
                    const hLine1 = hLines[j];
                    const hLine2 = hLines[j+1];

                    // calculate the 4 corner points of the polygon
                    const p1 = getIntersection(vLine1, hLine1);
                    const p2 = getIntersection(vLine2, hLine1);
                    const p3 = getIntersection(vLine2, hLine2);
                    const p4 = getIntersection(vLine1, hLine2);

                    // create the polygon element
                    const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                    poly.setAttribute('points', 
                        `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y} ${p4.x},${p4.y}`
                    );
                    
                    poly.setAttribute('class', 'retrowave-tile');
                    poly.setAttribute('fill', 'transparent');
                    poly.setAttribute('stroke', 'none');
                    poly.style.cursor = 'pointer';

                    // store tile data for debugging
                    poly.setAttribute('data-row', j);
                    poly.setAttribute('data-col', i);

                    poly.addEventListener('click', (e) => {
                        e.target.classList.toggle('tile-selected');
                    });

                    svg.appendChild(poly);
                }
            }
        }

        // animations

        // build the grid animation timeline (paused)
        const introTl = gsap.timeline({ paused: true });
        const [verticalLines, horizontalLines] = buildGrid();
        buildClickableLayer(horizontalLines, verticalLines);

        introTl.to(sceneTitle, {
            opacity: 1,
            scale: 1,
            duration: 1.5,
            ease: "power2.out"
        }, "0.5");

        horizontalLines.forEach((line) => {
            introTl.to(line.element, {
                attr: line.final,
                opacity: 1,
                duration: 1,
                ease: "power3.out"
            }, "0.2");
        });

        verticalLines.forEach((line) => {
            introTl.to(line.element, {
                attr: line.final,
                opacity: 1,
                duration: 1,
                ease: "power2.out"
            }, "0.4");
        });

        // button
        triggerWipe.addEventListener('click', () => {
            
            const masterTl = gsap.timeline();

            masterTl
                // fade out the original content
                .to(introContent, { 
                    autoAlpha: 0,
                    duration: 0.5 
                })
                // wipe UP to cover the screen
                .to(wipe, {
                    scaleY: 1,
                    duration: 0.5,
                    ease: "power2.inOut"
                }, "-=0.2") // Overlap with fade out slightly
                
                // once screen is black, swap content
                .set(introContent, { display: 'none' })
                .set(sceneContainer, { display: 'block' })
                
                // play grid animation
                .call(() => {
                    introTl.play();
                })
                
                // wipe down to reveal the new scene
                .to(wipe, {
                    scaleY: 0,
                    duration: 0.5,
                    ease: "power2.inOut"
                });

        }, { once: true }); // ensures the button can only be clicked once
    </script>

</body>
</html>